#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 4 2
    bytecblock 0x0000000000000000 "admin" "claimed_amount" "token_id" "start_ts" "period_secs" "payout_amount" "max_periods" "deposit_amount" "beneficiary" "flux_oracle_app_id" "fee_bps" "treasury" "contract_version"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    txn NumAppArgs
    bz main_after_if_else@12
    pushbytess 0xa713f6a9 0xa94bbc73 0x7299c577 0xaf97fe50 0x5ef62e1d 0x4351bbaa // method "createApplication(account,uint64,account,uint64,uint64,uint64)void", method "setFluxOracleAppId(uint64)void", method "setContractVersion(uint64)void", method "setAdmin(account)void", method "createRoute(account,uint64,uint64,uint64,uint64,uint64,uint64,axfer,pay)void", method "claim(axfer,pay,appl)void"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_setFluxOracleAppId_route@4 main_setContractVersion_route@5 main_setAdmin_route@6 main_createRoute_route@7 main_claim_route@8

main_after_if_else@12:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    intc_0 // 0
    return

main_claim_route@8:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:131
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_3 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:131
    // @abimethod({ allowActions: "NoOp" })
    callsub claim
    intc_1 // 1
    return

main_createRoute_route@7:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:77
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    btoi
    txn GroupIndex
    intc_3 // 2
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:77
    // @abimethod({ allowActions: "NoOp" })
    callsub createRoute
    intc_1 // 1
    return

main_setAdmin_route@6:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:71
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:71
    // @abimethod({ allowActions: "NoOp" })
    callsub setAdmin
    intc_1 // 1
    return

main_setContractVersion_route@5:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:66
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:66
    // @abimethod({ allowActions: "NoOp" })
    callsub setContractVersion
    intc_1 // 1
    return

main_setFluxOracleAppId_route@4:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:61
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:61
    // @abimethod({ allowActions: "NoOp" })
    callsub setFluxOracleAppId
    intc_1 // 1
    return

main_createApplication_route@3:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:43
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txnas Accounts
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:43
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    callsub createApplication
    intc_1 // 1
    return


// smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.createApplication(admin: bytes, fluxOracleAppId: uint64, treasury: bytes, feeBps: uint64, registryAppId: uint64, tokenId: uint64) -> void:
createApplication:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:43-44
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    // public createApplication(admin: Account, fluxOracleAppId: uint64, treasury: Account, feeBps: uint64, registryAppId: uint64, tokenId: uint64): void {
    proto 6 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:45
    // this.admin.value = admin.authAddress;
    frame_dig -6
    acct_params_get AcctAuthAddr
    assert // account funded
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:25
    // admin = GlobalState<Account>();
    bytec_1 // "admin"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:45
    // this.admin.value = admin.authAddress;
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:46
    // this.flux_oracle_app_id.value = new UintN64(fluxOracleAppId);
    frame_dig -5
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:26
    // flux_oracle_app_id = GlobalState<UintN64>();
    bytec 10 // "flux_oracle_app_id"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:46
    // this.flux_oracle_app_id.value = new UintN64(fluxOracleAppId);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:47
    // this.fee_bps.value = new UintN64(feeBps);
    frame_dig -3
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:28
    // fee_bps = GlobalState<UintN64>();
    bytec 11 // "fee_bps"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:47
    // this.fee_bps.value = new UintN64(feeBps);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:29
    // treasury = GlobalState<Account>();
    bytec 12 // "treasury"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:48
    // this.treasury.value = treasury;
    frame_dig -4
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:27
    // contract_version = GlobalState<UintN64>();
    bytec 13 // "contract_version"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:49
    // this.contract_version.value = new UintN64(CONTRACT_VERSION);
    pushbytes 0x00000000000003e8
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:50
    // this.registry_app_id.value = new UintN64(registryAppId);
    frame_dig -2
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:30
    // registry_app_id = GlobalState<UintN64>();
    pushbytes "registry_app_id"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:50
    // this.registry_app_id.value = new UintN64(registryAppId);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:51
    // this.token_id.value = new UintN64(tokenId);
    frame_dig -1
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:31
    // token_id = GlobalState<UintN64>();
    bytec_3 // "token_id"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:51
    // this.token_id.value = new UintN64(tokenId);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:36
    // start_ts = GlobalState<UintN64>();
    bytec 4 // "start_ts"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:53
    // this.start_ts.value = new UintN64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:37
    // period_secs = GlobalState<UintN64>();
    bytec 5 // "period_secs"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:54
    // this.period_secs.value = new UintN64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:38
    // payout_amount = GlobalState<UintN64>();
    bytec 6 // "payout_amount"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:55
    // this.payout_amount.value = new UintN64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:39
    // max_periods = GlobalState<UintN64>();
    bytec 7 // "max_periods"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:56
    // this.max_periods.value = new UintN64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:40
    // deposit_amount = GlobalState<UintN64>(); // total intended to stream
    bytec 8 // "deposit_amount"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:57
    // this.deposit_amount.value = new UintN64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:41
    // claimed_amount = GlobalState<UintN64>();
    bytec_2 // "claimed_amount"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:58
    // this.claimed_amount.value = new UintN64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    retsub


// smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.setFluxOracleAppId(fluxOracleAppId: uint64) -> void:
setFluxOracleAppId:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:61-62
    // @abimethod({ allowActions: "NoOp" })
    // public setFluxOracleAppId(fluxOracleAppId: uint64): void {
    proto 1 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:63
    // assert(op.Txn.sender === this.admin.value, "Only admin can set flux oracle app id");
    txn Sender
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:25
    // admin = GlobalState<Account>();
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:63
    // assert(op.Txn.sender === this.admin.value, "Only admin can set flux oracle app id");
    ==
    assert // Only admin can set flux oracle app id
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:64
    // this.flux_oracle_app_id.value = new UintN64(fluxOracleAppId);
    frame_dig -1
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:26
    // flux_oracle_app_id = GlobalState<UintN64>();
    bytec 10 // "flux_oracle_app_id"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:64
    // this.flux_oracle_app_id.value = new UintN64(fluxOracleAppId);
    swap
    app_global_put
    retsub


// smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.setContractVersion(contractVersion: uint64) -> void:
setContractVersion:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:66-67
    // @abimethod({ allowActions: "NoOp" })
    // public setContractVersion(contractVersion: uint64): void {
    proto 1 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:68
    // assert(op.Txn.sender === this.admin.value, "Only admin can set contract version");
    txn Sender
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:25
    // admin = GlobalState<Account>();
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:68
    // assert(op.Txn.sender === this.admin.value, "Only admin can set contract version");
    ==
    assert // Only admin can set contract version
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:69
    // this.contract_version.value = new UintN64(contractVersion);
    frame_dig -1
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:27
    // contract_version = GlobalState<UintN64>();
    bytec 13 // "contract_version"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:69
    // this.contract_version.value = new UintN64(contractVersion);
    swap
    app_global_put
    retsub


// smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.setAdmin(admin: bytes) -> void:
setAdmin:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:71-72
    // @abimethod({ allowActions: "NoOp" })
    // public setAdmin(admin: Account): void {
    proto 1 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:73
    // assert(op.Txn.sender === this.admin.value, "Only admin can set new admin");
    txn Sender
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:25
    // admin = GlobalState<Account>();
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:73
    // assert(op.Txn.sender === this.admin.value, "Only admin can set new admin");
    ==
    assert // Only admin can set new admin
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:25
    // admin = GlobalState<Account>();
    bytec_1 // "admin"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:74
    // this.admin.value = admin;
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.createRoute(beneficiary: bytes, startTs: uint64, periodSecs: uint64, payoutAmount: uint64, maxPeriods: uint64, depositAmount: uint64, tokenId: uint64, tokenTransfer: uint64, mbrTxn: uint64) -> void:
createRoute:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:77-88
    // @abimethod({ allowActions: "NoOp" })
    // public createRoute(
    //   beneficiary: Account,
    //   startTs: uint64,
    //   periodSecs: uint64,
    //   payoutAmount: uint64,
    //   maxPeriods: uint64,
    //   depositAmount: uint64,
    //   tokenId: uint64,
    //   tokenTransfer: gtxn.AssetTransferTxn,
    //   mbrTxn: gtxn.PaymentTxn
    // ): void {
    proto 9 0
    pushbytes ""
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:89
    // assert(periodSecs > 0, "Period seconds must be greater than 0");
    frame_dig -7
    assert // Period seconds must be greater than 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:90
    // assert(maxPeriods > 0, "Max periods must be greater than 0");
    frame_dig -5
    assert // Max periods must be greater than 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:91
    // assert(payoutAmount > 0, "Payout amount must be greater than 0");
    frame_dig -6
    assert // Payout amount must be greater than 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:92
    // assert(depositAmount > 0, "Deposit amount must be greater than 0");
    frame_dig -4
    assert // Deposit amount must be greater than 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:93
    // assert(tokenId > 0, "Token ID must be greater than 0");
    frame_dig -3
    assert // Token ID must be greater than 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:95-99
    // assertMatch(tokenTransfer, {
    //   xferAsset: Asset(tokenId),
    //   assetAmount: depositAmount,
    //   assetReceiver: Global.currentApplicationAddress,
    // });
    frame_dig -2
    gtxns XferAsset
    frame_dig -3
    ==
    bz createRoute_bool_false@4
    frame_dig -2
    gtxns AssetAmount
    frame_dig -4
    ==
    bz createRoute_bool_false@4
    frame_dig -2
    gtxns AssetReceiver
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:98
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:95-99
    // assertMatch(tokenTransfer, {
    //   xferAsset: Asset(tokenId),
    //   assetAmount: depositAmount,
    //   assetReceiver: Global.currentApplicationAddress,
    // });
    ==
    bz createRoute_bool_false@4
    intc_1 // 1

createRoute_bool_merge@5:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:95-99
    // assertMatch(tokenTransfer, {
    //   xferAsset: Asset(tokenId),
    //   assetAmount: depositAmount,
    //   assetReceiver: Global.currentApplicationAddress,
    // });
    assert // assert target is match for conditions
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:100-103
    // assertMatch(mbrTxn, {
    //   amount: depositAmount,
    //   receiver: Global.currentApplicationAddress,
    // });
    frame_dig -1
    gtxns Amount
    frame_dig -4
    ==
    bz createRoute_bool_false@8
    frame_dig -1
    gtxns Receiver
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:102
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:100-103
    // assertMatch(mbrTxn, {
    //   amount: depositAmount,
    //   receiver: Global.currentApplicationAddress,
    // });
    ==
    bz createRoute_bool_false@8
    intc_1 // 1

createRoute_bool_merge@9:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:100-103
    // assertMatch(mbrTxn, {
    //   amount: depositAmount,
    //   receiver: Global.currentApplicationAddress,
    // });
    assert // assert target is match for conditions
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:105
    // this.token_id.value = new UintN64(tokenId);
    frame_dig -3
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:31
    // token_id = GlobalState<UintN64>();
    bytec_3 // "token_id"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:105
    // this.token_id.value = new UintN64(tokenId);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:106
    // this.start_ts.value = new UintN64(startTs);
    frame_dig -8
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:36
    // start_ts = GlobalState<UintN64>();
    bytec 4 // "start_ts"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:106
    // this.start_ts.value = new UintN64(startTs);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:107
    // this.period_secs.value = new UintN64(periodSecs);
    frame_dig -7
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:37
    // period_secs = GlobalState<UintN64>();
    bytec 5 // "period_secs"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:107
    // this.period_secs.value = new UintN64(periodSecs);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:108
    // this.payout_amount.value = new UintN64(payoutAmount);
    frame_dig -6
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:38
    // payout_amount = GlobalState<UintN64>();
    bytec 6 // "payout_amount"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:108
    // this.payout_amount.value = new UintN64(payoutAmount);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:109
    // this.max_periods.value = new UintN64(maxPeriods);
    frame_dig -5
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:39
    // max_periods = GlobalState<UintN64>();
    bytec 7 // "max_periods"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:109
    // this.max_periods.value = new UintN64(maxPeriods);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:110
    // this.deposit_amount.value = new UintN64(depositAmount);
    frame_dig -4
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:40
    // deposit_amount = GlobalState<UintN64>(); // total intended to stream
    bytec 8 // "deposit_amount"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:110
    // this.deposit_amount.value = new UintN64(depositAmount);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:35
    // beneficiary = GlobalState<Address>();
    bytec 9 // "beneficiary"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:111
    // this.beneficiary.value = new Address(beneficiary);
    frame_dig -9
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:34
    // depositor = GlobalState<Address>();
    pushbytes "depositor"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:112
    // this.depositor.value = new Address(op.Txn.sender);
    txn Sender
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:28
    // fee_bps = GlobalState<UintN64>();
    intc_0 // 0
    bytec 11 // "fee_bps"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:117
    // const [feeHi, feeLo] = mulw(depositAmount, this.fee_bps.value.native);
    btoi
    frame_dig -4
    mulw
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:118
    // const fee: uint64 = divw(feeHi, feeLo, 10_000);
    pushint 10000 // 10000
    divw
    dup
    frame_bury 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:119
    // if (fee > 0) {
    bz createRoute_after_if_else@12
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:120-127
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.treasury.value,
    //     assetAmount: fee,
    //     xferAsset: Asset(tokenId),
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:29
    // treasury = GlobalState<Account>();
    intc_0 // 0
    bytec 12 // "treasury"
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -3
    itxn_field XferAsset
    frame_dig 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:120-126
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.treasury.value,
    //     assetAmount: fee,
    //     xferAsset: Asset(tokenId),
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/waypoint_linear/config.algo.ts:3
    // export const STANDARD_TXN_FEE: uint64 = 1000;
    pushint 1000 // 1000
    itxn_field Fee
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:120-127
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.treasury.value,
    //     assetAmount: fee,
    //     xferAsset: Asset(tokenId),
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit

createRoute_after_if_else@12:
    retsub

createRoute_bool_false@8:
    intc_0 // 0
    b createRoute_bool_merge@9

createRoute_bool_false@4:
    intc_0 // 0
    b createRoute_bool_merge@5


// smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.claim(_tokenTransfer: uint64, _mbrTxn: uint64, _fluxAppCall: uint64) -> void:
claim:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:131-132
    // @abimethod({ allowActions: "NoOp" })
    // public claim(_tokenTransfer: gtxn.AssetTransferTxn, _mbrTxn: gtxn.PaymentTxn, _fluxAppCall: gtxn.ApplicationCallTxn): void {
    proto 3 0
    pushbytes ""
    dupn 3
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:133
    // assert(op.Txn.sender === this.beneficiary.value.native, "Only beneficiary can claim");
    txn Sender
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:35
    // beneficiary = GlobalState<Address>();
    intc_0 // 0
    bytec 9 // "beneficiary"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:133
    // assert(op.Txn.sender === this.beneficiary.value.native, "Only beneficiary can claim");
    ==
    assert // Only beneficiary can claim
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:31
    // token_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "token_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:134
    // const tokenId = this.token_id.value.native;
    btoi
    dup
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:135
    // assert(tokenId > 0, "Route not initialized");
    assert // Route not initialized
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:137
    // const now = Global.latestTimestamp;
    global LatestTimestamp
    dup
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:36
    // start_ts = GlobalState<UintN64>();
    intc_0 // 0
    bytec 4 // "start_ts"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:155
    // const startTs: uint64 = this.start_ts.value.native;
    btoi
    dup
    cover 2
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:156
    // if (now <= startTs) {
    <=
    bz claim_after_if_else@8
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:157
    // return 0;
    intc_0 // 0
    frame_bury 3

claim_after_inlined_smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.vestedBySchedule@13:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:41
    // claimed_amount = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "claimed_amount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:185
    // const alreadyClaimed: uint64 = this.claimed_amount.value.native;
    btoi
    dup
    frame_bury 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:186
    // if (vested > alreadyClaimed) {
    frame_dig 3
    <
    bz claim_after_if_else@4
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:187
    // return vested - alreadyClaimed;
    frame_dig 3
    frame_dig 0
    -

claim_after_inlined_smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.computeClaimable@5:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:139
    // assert(claimableAmount > 0, "Nothing claimable yet");
    dup
    assert // Nothing claimable yet
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:141-148
    // itxn
    //   .assetTransfer({
    //     xferAsset: Asset(tokenId),
    //     assetAmount: claimableAmount,
    //     assetReceiver: this.beneficiary.value.native,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:35
    // beneficiary = GlobalState<Address>();
    intc_0 // 0
    bytec 9 // "beneficiary"
    app_global_get_ex
    assert // check GlobalState exists
    itxn_field AssetReceiver
    dup
    itxn_field AssetAmount
    frame_dig 4
    itxn_field XferAsset
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:141-147
    // itxn
    //   .assetTransfer({
    //     xferAsset: Asset(tokenId),
    //     assetAmount: claimableAmount,
    //     assetReceiver: this.beneficiary.value.native,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/waypoint_linear/config.algo.ts:3
    // export const STANDARD_TXN_FEE: uint64 = 1000;
    pushint 1000 // 1000
    itxn_field Fee
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:141-148
    // itxn
    //   .assetTransfer({
    //     xferAsset: Asset(tokenId),
    //     assetAmount: claimableAmount,
    //     assetReceiver: this.beneficiary.value.native,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:41
    // claimed_amount = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "claimed_amount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:150
    // const updatedClaimed: uint64 = this.claimed_amount.value.native + claimableAmount;
    btoi
    +
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:151
    // this.claimed_amount.value = new UintN64(updatedClaimed);
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:41
    // claimed_amount = GlobalState<UintN64>();
    bytec_2 // "claimed_amount"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:151
    // this.claimed_amount.value = new UintN64(updatedClaimed);
    swap
    app_global_put
    retsub

claim_after_if_else@4:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:190
    // return 0;
    intc_0 // 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:138
    // const claimableAmount = this.computeClaimable(now);
    b claim_after_inlined_smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.computeClaimable@5

claim_after_if_else@8:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:37
    // period_secs = GlobalState<UintN64>();
    intc_0 // 0
    bytec 5 // "period_secs"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:160
    // const periodSecs: uint64 = this.period_secs.value.native;
    btoi
    dup
    frame_bury 2
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:161
    // if (periodSecs === 0) {
    bnz claim_after_if_else@10
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:162
    // return 0;
    intc_0 // 0
    frame_bury 3
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:184
    // const vested = this.vestedBySchedule(now);
    b claim_after_inlined_smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.vestedBySchedule@13

claim_after_if_else@10:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:165
    // const elapsed: uint64 = now - startTs;
    frame_dig 5
    frame_dig 6
    -
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:166
    // const periodsElapsed: uint64 = divw(0, elapsed, periodSecs);
    intc_0 // 0
    swap
    frame_dig 2
    divw
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:39
    // max_periods = GlobalState<UintN64>();
    intc_0 // 0
    bytec 7 // "max_periods"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:168
    // const maxPeriods: uint64 = this.max_periods.value.native;
    btoi
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:169
    // const cappedPeriods: uint64 = periodsElapsed > maxPeriods ? maxPeriods : periodsElapsed;
    dup2
    >
    select
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:38
    // payout_amount = GlobalState<UintN64>();
    intc_0 // 0
    bytec 6 // "payout_amount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:171
    // const payoutAmount: uint64 = this.payout_amount.value.native;
    btoi
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:40
    // deposit_amount = GlobalState<UintN64>(); // total intended to stream
    intc_0 // 0
    bytec 8 // "deposit_amount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:172
    // const depositAmount: uint64 = this.deposit_amount.value.native;
    btoi
    cover 2
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:173
    // const [candidateHi, candidateLo] = mulw(payoutAmount, cappedPeriods);
    mulw
    frame_bury 1
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:175
    // if (candidateHi > 0) {
    bz claim_after_if_else@12
    frame_bury 3
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:184
    // const vested = this.vestedBySchedule(now);
    b claim_after_inlined_smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.vestedBySchedule@13

claim_after_if_else@12:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:180
    // return vestedCandidate > depositAmount ? depositAmount : vestedCandidate;
    frame_dig 1
    dup
    dig 2
    >
    swap
    cover 2
    select
    frame_bury 3
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:184
    // const vested = this.vestedBySchedule(now);
    b claim_after_inlined_smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.vestedBySchedule@13
