#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 4 1000
    bytecblock 0x0000000000000000 "admin" "token_id" "claimed_amount" "start_ts" "period_secs" "payout_amount" "max_periods" "deposit_amount" "beneficiary" "flux_oracle_app_id" "fee_bps" "treasury" "contract_version"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    txn NumAppArgs
    bz main_after_if_else@13
    pushbytess 0xa713f6a9 0xa94bbc73 0x7299c577 0xaf97fe50 0x9b932c59 0xc39b0dc4 0xf1577726 // method "createApplication(account,uint64,account,uint64,uint64,uint64)void", method "setFluxOracleAppId(uint64)void", method "setContractVersion(uint64)void", method "setAdmin(account)void", method "initApp(pay)void", method "createRoute(account,uint64,uint64,uint64,uint64,uint64,uint64,axfer)void", method "claim()void"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_setFluxOracleAppId_route@4 main_setContractVersion_route@5 main_setAdmin_route@6 main_initApp_route@7 main_createRoute_route@8 main_claim_route@9

main_after_if_else@13:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    intc_0 // 0
    return

main_claim_route@9:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:151
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub claim
    intc_1 // 1
    return

main_createRoute_route@8:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:102
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    btoi
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:102
    // @abimethod({ allowActions: "NoOp" })
    callsub createRoute
    intc_1 // 1
    return

main_initApp_route@7:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:84
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:84
    // @abimethod({ allowActions: "NoOp" })
    callsub initApp
    intc_1 // 1
    return

main_setAdmin_route@6:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:78
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:78
    // @abimethod({ allowActions: "NoOp" })
    callsub setAdmin
    intc_1 // 1
    return

main_setContractVersion_route@5:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:73
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:73
    // @abimethod({ allowActions: "NoOp" })
    callsub setContractVersion
    intc_1 // 1
    return

main_setFluxOracleAppId_route@4:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:68
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:68
    // @abimethod({ allowActions: "NoOp" })
    callsub setFluxOracleAppId
    intc_1 // 1
    return

main_createApplication_route@3:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:43
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:22-23
    // @contract({ name: "waypoint-linear", avmVersion: 11 })
    // export class WaypointLinear extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txnas Accounts
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:43
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    callsub createApplication
    intc_1 // 1
    return


// smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.createApplication(admin: bytes, fluxOracleAppId: uint64, treasury: bytes, feeBps: uint64, registryAppId: uint64, tokenId: uint64) -> void:
createApplication:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:43-51
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    // public createApplication(
    //   admin: Account,
    //   fluxOracleAppId: uint64,
    //   treasury: Account,
    //   feeBps: uint64,
    //   registryAppId: uint64,
    //   tokenId: uint64
    // ): void {
    proto 6 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:52
    // this.admin.value = admin.authAddress;
    frame_dig -6
    acct_params_get AcctAuthAddr
    assert // account funded
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:25
    // admin = GlobalState<Account>();
    bytec_1 // "admin"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:52
    // this.admin.value = admin.authAddress;
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:53
    // this.flux_oracle_app_id.value = new UintN64(fluxOracleAppId);
    frame_dig -5
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:26
    // flux_oracle_app_id = GlobalState<UintN64>();
    bytec 10 // "flux_oracle_app_id"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:53
    // this.flux_oracle_app_id.value = new UintN64(fluxOracleAppId);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:54
    // this.fee_bps.value = new UintN64(feeBps);
    frame_dig -3
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:28
    // fee_bps = GlobalState<UintN64>();
    bytec 11 // "fee_bps"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:54
    // this.fee_bps.value = new UintN64(feeBps);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:29
    // treasury = GlobalState<Account>();
    bytec 12 // "treasury"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:55
    // this.treasury.value = treasury;
    frame_dig -4
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:27
    // contract_version = GlobalState<UintN64>();
    bytec 13 // "contract_version"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:56
    // this.contract_version.value = new UintN64(CONTRACT_VERSION);
    pushbytes 0x00000000000003e8
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:57
    // this.registry_app_id.value = new UintN64(registryAppId);
    frame_dig -2
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:30
    // registry_app_id = GlobalState<UintN64>();
    pushbytes "registry_app_id"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:57
    // this.registry_app_id.value = new UintN64(registryAppId);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:58
    // this.token_id.value = new UintN64(tokenId);
    frame_dig -1
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:31
    // token_id = GlobalState<UintN64>();
    bytec_2 // "token_id"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:58
    // this.token_id.value = new UintN64(tokenId);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:36
    // start_ts = GlobalState<UintN64>();
    bytec 4 // "start_ts"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:60
    // this.start_ts.value = new UintN64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:37
    // period_secs = GlobalState<UintN64>();
    bytec 5 // "period_secs"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:61
    // this.period_secs.value = new UintN64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:38
    // payout_amount = GlobalState<UintN64>();
    bytec 6 // "payout_amount"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:62
    // this.payout_amount.value = new UintN64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:39
    // max_periods = GlobalState<UintN64>();
    bytec 7 // "max_periods"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:63
    // this.max_periods.value = new UintN64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:40
    // deposit_amount = GlobalState<UintN64>(); // total intended to stream
    bytec 8 // "deposit_amount"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:64
    // this.deposit_amount.value = new UintN64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:41
    // claimed_amount = GlobalState<UintN64>();
    bytec_3 // "claimed_amount"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:65
    // this.claimed_amount.value = new UintN64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    retsub


// smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.setFluxOracleAppId(fluxOracleAppId: uint64) -> void:
setFluxOracleAppId:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:68-69
    // @abimethod({ allowActions: "NoOp" })
    // public setFluxOracleAppId(fluxOracleAppId: uint64): void {
    proto 1 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:70
    // assert(op.Txn.sender === this.admin.value, "Only admin can set flux oracle app id");
    txn Sender
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:25
    // admin = GlobalState<Account>();
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:70
    // assert(op.Txn.sender === this.admin.value, "Only admin can set flux oracle app id");
    ==
    assert // Only admin can set flux oracle app id
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:71
    // this.flux_oracle_app_id.value = new UintN64(fluxOracleAppId);
    frame_dig -1
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:26
    // flux_oracle_app_id = GlobalState<UintN64>();
    bytec 10 // "flux_oracle_app_id"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:71
    // this.flux_oracle_app_id.value = new UintN64(fluxOracleAppId);
    swap
    app_global_put
    retsub


// smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.setContractVersion(contractVersion: uint64) -> void:
setContractVersion:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:73-74
    // @abimethod({ allowActions: "NoOp" })
    // public setContractVersion(contractVersion: uint64): void {
    proto 1 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:75
    // assert(op.Txn.sender === this.admin.value, "Only admin can set contract version");
    txn Sender
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:25
    // admin = GlobalState<Account>();
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:75
    // assert(op.Txn.sender === this.admin.value, "Only admin can set contract version");
    ==
    assert // Only admin can set contract version
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:76
    // this.contract_version.value = new UintN64(contractVersion);
    frame_dig -1
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:27
    // contract_version = GlobalState<UintN64>();
    bytec 13 // "contract_version"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:76
    // this.contract_version.value = new UintN64(contractVersion);
    swap
    app_global_put
    retsub


// smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.setAdmin(admin: bytes) -> void:
setAdmin:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:78-79
    // @abimethod({ allowActions: "NoOp" })
    // public setAdmin(admin: Account): void {
    proto 1 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:80
    // assert(op.Txn.sender === this.admin.value, "Only admin can set new admin");
    txn Sender
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:25
    // admin = GlobalState<Account>();
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:80
    // assert(op.Txn.sender === this.admin.value, "Only admin can set new admin");
    ==
    assert // Only admin can set new admin
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:25
    // admin = GlobalState<Account>();
    bytec_1 // "admin"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:81
    // this.admin.value = admin;
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.initApp(mbrTxn: uint64) -> void:
initApp:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:84-85
    // @abimethod({ allowActions: "NoOp" })
    // public initApp(mbrTxn: gtxn.PaymentTxn): void {
    proto 1 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:86-89
    // assertMatch(mbrTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: 202_000,
    // });
    frame_dig -1
    gtxns Receiver
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:87
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:86-89
    // assertMatch(mbrTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: 202_000,
    // });
    ==
    bz initApp_bool_false@3
    frame_dig -1
    gtxns Amount
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:88
    // amount: 202_000,
    pushint 202000 // 202000
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:86-89
    // assertMatch(mbrTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: 202_000,
    // });
    ==
    bz initApp_bool_false@3
    intc_1 // 1

initApp_bool_merge@4:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:86-89
    // assertMatch(mbrTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: 202_000,
    // });
    assert // assert target is match for conditions
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:91-99
    // itxn
    //   .assetTransfer({
    //     sender: Global.currentApplicationAddress,
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: Asset(this.token_id.value.native),
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:93
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:94
    // assetReceiver: Global.currentApplicationAddress,
    dup
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:31
    // token_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "token_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:95
    // xferAsset: Asset(this.token_id.value.native),
    btoi
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:96
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:91-98
    // itxn
    //   .assetTransfer({
    //     sender: Global.currentApplicationAddress,
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: Asset(this.token_id.value.native),
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/waypoint_linear/config.algo.ts:3
    // export const STANDARD_TXN_FEE: uint64 = 1000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:91-99
    // itxn
    //   .assetTransfer({
    //     sender: Global.currentApplicationAddress,
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: Asset(this.token_id.value.native),
    //     assetAmount: 0,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    retsub

initApp_bool_false@3:
    intc_0 // 0
    b initApp_bool_merge@4


// smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.createRoute(beneficiary: bytes, startTs: uint64, periodSecs: uint64, payoutAmount: uint64, maxPeriods: uint64, depositAmount: uint64, tokenId: uint64, tokenTransfer: uint64) -> void:
createRoute:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:102-112
    // @abimethod({ allowActions: "NoOp" })
    // public createRoute(
    //   beneficiary: Account,
    //   startTs: uint64,
    //   periodSecs: uint64,
    //   payoutAmount: uint64,
    //   maxPeriods: uint64,
    //   depositAmount: uint64,
    //   tokenId: uint64,
    //   tokenTransfer: gtxn.AssetTransferTxn
    // ): void {
    proto 8 0
    pushbytes ""
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:113
    // assert(periodSecs > 0, "Period seconds must be greater than 0");
    frame_dig -6
    assert // Period seconds must be greater than 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:114
    // assert(maxPeriods > 0, "Max periods must be greater than 0");
    frame_dig -4
    assert // Max periods must be greater than 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:115
    // assert(payoutAmount > 0, "Payout amount must be greater than 0");
    frame_dig -5
    assert // Payout amount must be greater than 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:116
    // assert(depositAmount > 0, "Deposit amount must be greater than 0");
    frame_dig -3
    assert // Deposit amount must be greater than 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:117
    // assert(tokenId > 0, "Token ID must be greater than 0");
    frame_dig -2
    assert // Token ID must be greater than 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:119-123
    // assertMatch(tokenTransfer, {
    //   xferAsset: Asset(tokenId),
    //   assetAmount: depositAmount,
    //   assetReceiver: Global.currentApplicationAddress,
    // });
    frame_dig -1
    gtxns XferAsset
    frame_dig -2
    ==
    bz createRoute_bool_false@4
    frame_dig -1
    gtxns AssetAmount
    frame_dig -3
    ==
    bz createRoute_bool_false@4
    frame_dig -1
    gtxns AssetReceiver
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:122
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:119-123
    // assertMatch(tokenTransfer, {
    //   xferAsset: Asset(tokenId),
    //   assetAmount: depositAmount,
    //   assetReceiver: Global.currentApplicationAddress,
    // });
    ==
    bz createRoute_bool_false@4
    intc_1 // 1

createRoute_bool_merge@5:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:119-123
    // assertMatch(tokenTransfer, {
    //   xferAsset: Asset(tokenId),
    //   assetAmount: depositAmount,
    //   assetReceiver: Global.currentApplicationAddress,
    // });
    assert // assert target is match for conditions
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:125
    // this.token_id.value = new UintN64(tokenId);
    frame_dig -2
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:31
    // token_id = GlobalState<UintN64>();
    bytec_2 // "token_id"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:125
    // this.token_id.value = new UintN64(tokenId);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:126
    // this.start_ts.value = new UintN64(startTs); // DEBUG: subtract time to allow immediate claim
    frame_dig -7
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:36
    // start_ts = GlobalState<UintN64>();
    bytec 4 // "start_ts"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:126
    // this.start_ts.value = new UintN64(startTs); // DEBUG: subtract time to allow immediate claim
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:127
    // this.period_secs.value = new UintN64(periodSecs);
    frame_dig -6
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:37
    // period_secs = GlobalState<UintN64>();
    bytec 5 // "period_secs"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:127
    // this.period_secs.value = new UintN64(periodSecs);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:128
    // this.payout_amount.value = new UintN64(payoutAmount);
    frame_dig -5
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:38
    // payout_amount = GlobalState<UintN64>();
    bytec 6 // "payout_amount"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:128
    // this.payout_amount.value = new UintN64(payoutAmount);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:129
    // this.max_periods.value = new UintN64(maxPeriods);
    frame_dig -4
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:39
    // max_periods = GlobalState<UintN64>();
    bytec 7 // "max_periods"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:129
    // this.max_periods.value = new UintN64(maxPeriods);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:130
    // this.deposit_amount.value = new UintN64(depositAmount);
    frame_dig -3
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:40
    // deposit_amount = GlobalState<UintN64>(); // total intended to stream
    bytec 8 // "deposit_amount"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:130
    // this.deposit_amount.value = new UintN64(depositAmount);
    swap
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:35
    // beneficiary = GlobalState<Address>();
    bytec 9 // "beneficiary"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:131
    // this.beneficiary.value = new Address(beneficiary);
    frame_dig -8
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:34
    // depositor = GlobalState<Address>();
    pushbytes "depositor"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:132
    // this.depositor.value = new Address(op.Txn.sender);
    txn Sender
    app_global_put
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:28
    // fee_bps = GlobalState<UintN64>();
    intc_0 // 0
    bytec 11 // "fee_bps"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:137
    // const [feeHi, feeLo] = mulw(depositAmount, this.fee_bps.value.native);
    btoi
    frame_dig -3
    mulw
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:138
    // const fee: uint64 = divw(feeHi, feeLo, 10_000);
    pushint 10000 // 10000
    divw
    dup
    frame_bury 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:139
    // if (fee > 0) {
    bz createRoute_after_if_else@8
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:140-147
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.treasury.value,
    //     assetAmount: fee,
    //     xferAsset: Asset(tokenId),
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:29
    // treasury = GlobalState<Account>();
    intc_0 // 0
    bytec 12 // "treasury"
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -2
    itxn_field XferAsset
    frame_dig 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:140-146
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.treasury.value,
    //     assetAmount: fee,
    //     xferAsset: Asset(tokenId),
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/waypoint_linear/config.algo.ts:3
    // export const STANDARD_TXN_FEE: uint64 = 1000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:140-147
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.treasury.value,
    //     assetAmount: fee,
    //     xferAsset: Asset(tokenId),
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit

createRoute_after_if_else@8:
    retsub

createRoute_bool_false@4:
    intc_0 // 0
    b createRoute_bool_merge@5


// smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.claim() -> void:
claim:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:151-152
    // @abimethod({ allowActions: "NoOp" })
    // public claim(): void {
    proto 0 0
    pushbytes ""
    dupn 3
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:153
    // assert(op.Txn.sender === this.beneficiary.value.native, "Only beneficiary can claim");
    txn Sender
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:35
    // beneficiary = GlobalState<Address>();
    intc_0 // 0
    bytec 9 // "beneficiary"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:153
    // assert(op.Txn.sender === this.beneficiary.value.native, "Only beneficiary can claim");
    ==
    assert // Only beneficiary can claim
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:31
    // token_id = GlobalState<UintN64>();
    intc_0 // 0
    bytec_2 // "token_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:154
    // const tokenId = this.token_id.value.native;
    btoi
    dup
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:155
    // assert(tokenId > 0, "Route not initialized");
    assert // Route not initialized
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:157
    // const now = Global.latestTimestamp;
    global LatestTimestamp
    dup
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:36
    // start_ts = GlobalState<UintN64>();
    intc_0 // 0
    bytec 4 // "start_ts"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:175
    // const startTs: uint64 = this.start_ts.value.native;
    btoi
    dup
    cover 2
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:176
    // if (now <= startTs) {
    <=
    bz claim_after_if_else@8
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:177
    // return 0;
    intc_0 // 0
    frame_bury 3

claim_after_inlined_smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.vestedBySchedule@13:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:41
    // claimed_amount = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "claimed_amount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:205
    // const alreadyClaimed: uint64 = this.claimed_amount.value.native;
    btoi
    dup
    frame_bury 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:206
    // if (vested > alreadyClaimed) {
    frame_dig 3
    <
    bz claim_after_if_else@4
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:207
    // return vested - alreadyClaimed;
    frame_dig 3
    frame_dig 0
    -

claim_after_inlined_smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.computeClaimable@5:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:159
    // assert(claimableAmount > 0, "Nothing claimable yet");
    dup
    assert // Nothing claimable yet
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:161-168
    // itxn
    //   .assetTransfer({
    //     xferAsset: Asset(tokenId),
    //     assetAmount: claimableAmount,
    //     assetReceiver: this.beneficiary.value.native,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:35
    // beneficiary = GlobalState<Address>();
    intc_0 // 0
    bytec 9 // "beneficiary"
    app_global_get_ex
    assert // check GlobalState exists
    itxn_field AssetReceiver
    dup
    itxn_field AssetAmount
    frame_dig 4
    itxn_field XferAsset
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:161-167
    // itxn
    //   .assetTransfer({
    //     xferAsset: Asset(tokenId),
    //     assetAmount: claimableAmount,
    //     assetReceiver: this.beneficiary.value.native,
    //     fee: STANDARD_TXN_FEE,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/waypoint_linear/config.algo.ts:3
    // export const STANDARD_TXN_FEE: uint64 = 1000;
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:161-168
    // itxn
    //   .assetTransfer({
    //     xferAsset: Asset(tokenId),
    //     assetAmount: claimableAmount,
    //     assetReceiver: this.beneficiary.value.native,
    //     fee: STANDARD_TXN_FEE,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:41
    // claimed_amount = GlobalState<UintN64>();
    intc_0 // 0
    bytec_3 // "claimed_amount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:170
    // const updatedClaimed: uint64 = this.claimed_amount.value.native + claimableAmount;
    btoi
    +
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:171
    // this.claimed_amount.value = new UintN64(updatedClaimed);
    itob
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:41
    // claimed_amount = GlobalState<UintN64>();
    bytec_3 // "claimed_amount"
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:171
    // this.claimed_amount.value = new UintN64(updatedClaimed);
    swap
    app_global_put
    retsub

claim_after_if_else@4:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:210
    // return 0;
    intc_0 // 0
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:158
    // const claimableAmount = this.computeClaimable(now);
    b claim_after_inlined_smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.computeClaimable@5

claim_after_if_else@8:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:37
    // period_secs = GlobalState<UintN64>();
    intc_0 // 0
    bytec 5 // "period_secs"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:180
    // const periodSecs: uint64 = this.period_secs.value.native;
    btoi
    dup
    frame_bury 2
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:181
    // if (periodSecs === 0) {
    bnz claim_after_if_else@10
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:182
    // return 0;
    intc_0 // 0
    frame_bury 3
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:204
    // const vested = this.vestedBySchedule(now);
    b claim_after_inlined_smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.vestedBySchedule@13

claim_after_if_else@10:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:185
    // const elapsed: uint64 = now - startTs;
    frame_dig 5
    frame_dig 6
    -
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:186
    // const periodsElapsed: uint64 = divw(0, elapsed, periodSecs);
    intc_0 // 0
    swap
    frame_dig 2
    divw
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:39
    // max_periods = GlobalState<UintN64>();
    intc_0 // 0
    bytec 7 // "max_periods"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:188
    // const maxPeriods: uint64 = this.max_periods.value.native;
    btoi
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:189
    // const cappedPeriods: uint64 = periodsElapsed > maxPeriods ? maxPeriods : periodsElapsed;
    dup2
    >
    select
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:38
    // payout_amount = GlobalState<UintN64>();
    intc_0 // 0
    bytec 6 // "payout_amount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:191
    // const payoutAmount: uint64 = this.payout_amount.value.native;
    btoi
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:40
    // deposit_amount = GlobalState<UintN64>(); // total intended to stream
    intc_0 // 0
    bytec 8 // "deposit_amount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:192
    // const depositAmount: uint64 = this.deposit_amount.value.native;
    btoi
    cover 2
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:193
    // const [candidateHi, candidateLo] = mulw(payoutAmount, cappedPeriods);
    mulw
    frame_bury 1
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:195
    // if (candidateHi > 0) {
    bz claim_after_if_else@12
    frame_bury 3
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:204
    // const vested = this.vestedBySchedule(now);
    b claim_after_inlined_smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.vestedBySchedule@13

claim_after_if_else@12:
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:200
    // return vestedCandidate > depositAmount ? depositAmount : vestedCandidate;
    frame_dig 1
    dup
    dig 2
    >
    swap
    cover 2
    select
    frame_bury 3
    // smart_contracts/waypoint_linear/waypoint-linear.algo.ts:204
    // const vested = this.vestedBySchedule(now);
    b claim_after_inlined_smart_contracts/waypoint_linear/waypoint-linear.algo.ts::WaypointLinear.vestedBySchedule@13
